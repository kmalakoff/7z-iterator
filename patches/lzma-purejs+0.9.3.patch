diff --git a/node_modules/lzma-purejs/lib/LZMA/Decoder.js b/node_modules/lzma-purejs/lib/LZMA/Decoder.js
index b82db68..3a124a1 100644
--- a/node_modules/lzma-purejs/lib/LZMA/Decoder.js
+++ b/node_modules/lzma-purejs/lib/LZMA/Decoder.js
@@ -163,11 +163,26 @@ var Decoder = function(){
   this._dictionarySizeCheck = -1;
   this._posStateMask = 0;
 
+  // LZMA2 state preservation: these were local vars in code(), now instance props
+  this._state = 0;
+  this._rep0 = 0;
+  this._rep1 = 0;
+  this._rep2 = 0;
+  this._rep3 = 0;
+  this._prevByte = 0;
+  this._nowPos64 = 0; // Cumulative position for solid mode
+  this._solid = false; // When true, don't reset state in code()
+
   for (i=0; i<Base.kNumLenToPosStates; i++) {
     this._posSlotDecoder[i] = new RangeCoder.BitTreeDecoder(Base.kNumPosSlotBits);
   }
 };
 
+// LZMA2 support: Set solid mode to preserve state across chunks
+Decoder.prototype.setSolid = function(solid) {
+  this._solid = solid;
+};
+
 Decoder.prototype.setDictionarySize = function(dictionarySize){
   if (dictionarySize < 0){
     return false;
@@ -224,100 +239,120 @@ Decoder.prototype.init = function(){
 Decoder.prototype.code = function(inStream, outStream, outSize){
   // note that nowPos64 is actually only 53 bits long; that sets a limit
   // on the amount of data we can decode
-  var state, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
-      posState, decoder2, len, distance, posSlot, numDirectBits;
+  // LZMA2 patch: use instance properties for state vars instead of locals
+  // chunkPos tracks bytes in current chunk (for loop termination)
+  // cumPos tracks cumulative bytes across chunks (for posState, literal context, rep0 validation)
+  var chunkPos = 0, posState, decoder2, len, distance, posSlot, numDirectBits;
+  var cumPos;
 
   this._rangeDecoder.setStream(inStream);
   this._outWindow.setStream(outStream);
 
-  this.init();
+  // LZMA2 patch: only init when not in solid mode (state preservation)
+  if (!this._solid) {
+    this.init();
+    this._state = Base.stateInit();
+    this._rep0 = 0;
+    this._rep1 = 0;
+    this._rep2 = 0;
+    this._rep3 = 0;
+    this._prevByte = 0;
+    this._nowPos64 = 0;
+  } else {
+    // In solid mode, preserve dictionary (pass true), just init the range decoder
+    this._outWindow.init(true);
+    this._rangeDecoder.init();
+  }
+  cumPos = this._nowPos64;
 
-  state = Base.stateInit();
-  while(outSize < 0 || nowPos64 < outSize){
-    posState = nowPos64 & this._posStateMask;
+  while(outSize < 0 || chunkPos < outSize){
+    posState = cumPos & this._posStateMask;
 
-    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << Base.kNumPosStatesBitsMax) + posState) === 0){
-      decoder2 = this._literalDecoder.getDecoder(nowPos64, prevByte);
+    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (this._state << Base.kNumPosStatesBitsMax) + posState) === 0){
+      decoder2 = this._literalDecoder.getDecoder(cumPos, this._prevByte);
 
-      if (!Base.stateIsCharState(state)){
-        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
+      if (!Base.stateIsCharState(this._state)){
+        this._prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(this._rep0) );
       }else{
-        prevByte = decoder2.decodeNormal(this._rangeDecoder);
+        this._prevByte = decoder2.decodeNormal(this._rangeDecoder);
       }
-      this._outWindow.putByte(prevByte);
-      state = Base.stateUpdateChar(state);
-      nowPos64++;
+      this._outWindow.putByte(this._prevByte);
+      this._state = Base.stateUpdateChar(this._state);
+      chunkPos++; cumPos++;
 
     }else{
 
-      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
+      if (this._rangeDecoder.decodeBit(this._isRepDecoders, this._state) === 1){
         len = 0;
-        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
-          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << Base.kNumPosStatesBitsMax) + posState) === 0){
-            state = Base.stateUpdateShortRep(state);
+        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, this._state) === 0){
+          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (this._state << Base.kNumPosStatesBitsMax) + posState) === 0){
+            this._state = Base.stateUpdateShortRep(this._state);
             len = 1;
           }
         }else{
-          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
-            distance = rep1;
+          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, this._state) === 0){
+            distance = this._rep1;
           }else{
-            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
-              distance = rep2;
+            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, this._state) === 0){
+              distance = this._rep2;
             }else{
-              distance = rep3;
-              rep3 = rep2;
+              distance = this._rep3;
+              this._rep3 = this._rep2;
             }
-            rep2 = rep1;
+            this._rep2 = this._rep1;
           }
-          rep1 = rep0;
-          rep0 = distance;
+          this._rep1 = this._rep0;
+          this._rep0 = distance;
         }
         if (len === 0){
           len = Base.kMatchMinLen + this._repLenDecoder.decode(this._rangeDecoder, posState);
-          state = Base.stateUpdateRep(state);
+          this._state = Base.stateUpdateRep(this._state);
         }
       }else{
-        rep3 = rep2;
-        rep2 = rep1;
-        rep1 = rep0;
+        this._rep3 = this._rep2;
+        this._rep2 = this._rep1;
+        this._rep1 = this._rep0;
 
         len = Base.kMatchMinLen + this._lenDecoder.decode(this._rangeDecoder, posState);
-        state = Base.stateUpdateMatch(state);
+        this._state = Base.stateUpdateMatch(this._state);
 
         posSlot = this._posSlotDecoder[Base.getLenToPosState(len)].decode(this._rangeDecoder);
         if (posSlot >= Base.kStartPosModelIndex){
 
           numDirectBits = (posSlot >> 1) - 1;
-          rep0 = (2 | (posSlot & 1) ) << numDirectBits;
+          this._rep0 = (2 | (posSlot & 1) ) << numDirectBits;
 
           if (posSlot < Base.kEndPosModelIndex){
-            rep0 += RangeCoder.BitTreeDecoder.reverseDecode(this._posDecoders,
-                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
+            this._rep0 += RangeCoder.BitTreeDecoder.reverseDecode(this._posDecoders,
+                this._rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
           }else{
-            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits;
-            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
-            if (rep0 < 0){
-              if (rep0 === -1){
+            this._rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits;
+            this._rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
+            if (this._rep0 < 0){
+              if (this._rep0 === -1){
                 break;
               }
               return false;
             }
           }
         }else{
-          rep0 = posSlot;
+          this._rep0 = posSlot;
         }
       }
 
-      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
+      if (this._rep0 >= cumPos || this._rep0 >= this._dictionarySizeCheck){
         return false;
       }
 
-      this._outWindow.copyBlock(rep0, len);
-      nowPos64 += len;
-      prevByte = this._outWindow.getByte(0);
+      this._outWindow.copyBlock(this._rep0, len);
+      chunkPos += len; cumPos += len;
+      this._prevByte = this._outWindow.getByte(0);
     }
   }
 
+  // LZMA2: save cumulative position for next solid chunk
+  this._nowPos64 = cumPos;
+
   this._outWindow.flush();
   this._outWindow.releaseStream();
   this._rangeDecoder.releaseStream();
